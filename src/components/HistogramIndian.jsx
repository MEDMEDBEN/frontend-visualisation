import React, { useEffect, useRef, useContext } from 'react'
import * as d3 from 'd3'
import '../styles/HistogramIndian.css'
import { CityContext } from '../context/CityContext'

export default function HistogramIndian(){
  const { data: data, selectedCity } = useContext(CityContext)
  const svgRef = useRef()
  const wrapperRef = useRef()

  // Draw chart when data or selection changes
  useEffect(()=>{
    if(!data || data.length===0 || !selectedCity) return

    // Prepare aggregated data: years x types
    const filtered = data.filter(d=>d.city === selectedCity)
    const years = Array.from(new Set(filtered.map(d=>d.year))).sort((a,b)=>a-b)
    const types = Array.from(new Set(filtered.map(d=>d.type))).sort()

    // Nested sums per year/type
    const sumMap = new Map()
    filtered.forEach(d=>{
      const key = d.year + '|' + d.type
      sumMap.set(key, (sumMap.get(key)||0) + d.value)
    })

    const series = years.map(year => ({
      year,
      values: types.map(type => ({ type, value: sumMap.get(year+'|'+type) || 0 }))
    }))

    drawGroupedBar(svgRef.current, wrapperRef.current, { series, years, types })
  },[data, selectedCity])

  return (
    <div className="hist-card" ref={wrapperRef}>
      <div className="hist-header">
        <h2>Waste Generated by Type â€” Grouped by Year</h2>
      </div>

      <svg ref={svgRef} className="hist-svg" />
      <div className="hist-tooltip" style={{display:'none'}} />

      <div className="hist-legend" aria-hidden />
    </div>
  )
}

function drawGroupedBar(svgNode, wrapperNode, { series, years, types }) {
  const margin = { top: 12, right: 10, bottom: 80, left: 50 }
  const containerWidth = wrapperNode ? wrapperNode.clientWidth : 800

  const computedBaseWidth = Math.min(1200, Math.max(600, containerWidth * 1)) - margin.left - margin.right
  const computedBaseHeight = 420 - margin.top - margin.bottom

  const width = Math.max(0, computedBaseWidth - 5)
  const height = Math.max(0, computedBaseHeight - 5)

  const svg = d3.select(svgNode)
  svg.selectAll('*').remove()
  svg.attr('width', width + margin.left + margin.right)
     .attr('height', height + margin.top + margin.bottom)

  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`)

  const x0 = d3.scaleBand().domain(years).rangeRound([0, width]).paddingInner(0.2)
  const x1 = d3.scaleBand().domain(types).rangeRound([0, x0.bandwidth()]).padding(0.08)
  const y = d3.scaleLinear().rangeRound([height, 0])

  const maxVal = d3.max(series, s => d3.max(s.values, v => v.value)) || 0
  y.domain([0, maxVal * 1.05])

  /** --------------------------------------------------
   * ðŸŽ¨ PALETTE â€” Tous types CSV
   * -------------------------------------------------- */
  // Use the app central palette (pastel wheel) for all hist bars.
  // Preference: read from CSS variables --chart-1..--chart-5 if present,
  // otherwise fall back to these exact hex values extracted from the donut image.
  const defaultPalette = ['#B99BFF','#7FC8A0','#8AD1FF','#F6D87A','#9EA0B8']
  const cssVars = typeof window !== 'undefined' && window.getComputedStyle ? window.getComputedStyle(document.documentElement) : null
  const palette = []
  for(let i=1;i<=5;i++){
    const v = cssVars ? cssVars.getPropertyValue(`--chart-${i}`) : ''
    palette.push((v && v.trim()) || defaultPalette[i-1])
  }
  // If more categories exist, create blended variations by rotating the base palette
  const rawTypes = types
  const colorMap = new Map()
  rawTypes.forEach((t, i) => {
    const base = palette[i % palette.length]
    // blend slightly with next color to produce visual variety when needed
    const next = palette[(i+1) % palette.length]
    const mix = d3.interpolateRgb(base, next)(0.28)
    colorMap.set(t, mix)
  })
  const getColorForRaw = raw => colorMap.get(raw) || defaultPalette[0]

  // Axes
  g.append('g')
    .attr('class', 'axis x-axis')
    .attr('transform', `translate(0,${height})`)
    .call(d3.axisBottom(x0).tickSizeOuter(0))

  g.append('g')
    .attr('class', 'axis y-axis')
    .call(d3.axisLeft(y).ticks(6).tickFormat(d3.format('~s')))

  // Bars
  const yearG = g.selectAll('.year-group')
    .data(series)
    .join('g')
      .attr('class', 'year-group')
      .attr('transform', d => `translate(${x0(d.year)},0)`)

  const bars = yearG.selectAll('rect')
    .data(d => d.values.map(v => ({ year: d.year, type: v.type, value: v.value })))
    .join('rect')
      .attr('x', d => x1(d.type))
      .attr('y', y(0))
      .attr('width', x1.bandwidth())
      .attr('height', 0)
      .attr('fill', d => getColorForRaw(d.type))
      .attr('rx', 2)
      .on('mouseover', function (event, d) {
        d3.select(this).attr('opacity', 0.75)
        const tip = d3.select(wrapperNode).select('.hist-tooltip')
        tip.style('display', 'block')
        tip.html(`<div class="tip-title">${d.type}</div><div><strong>AnnÃ©e:</strong> ${d.year}</div><div><strong>Valeur:</strong> ${d3.format(',')(d.value)}</div>`)
        tip.classed('show', true)
        const [mx, my] = d3.pointer(event, wrapperNode)
        tip.style('left', `${Math.min(wrapperNode.clientWidth - 220, mx + 14)}px`).style('top', `${Math.max(8, my + 10)}px`)
      })
      .on('mousemove', function (event) {
        const tip = d3.select(wrapperNode).select('.hist-tooltip')
        const [mx, my] = d3.pointer(event, wrapperNode)
        tip.style('left', `${Math.min(wrapperNode.clientWidth - 220, mx + 14)}px`).style('top', `${Math.max(8, my + 10)}px`)
      })
      .on('mouseout', function () {
        d3.select(this).attr('opacity', 1)
        const tip = d3.select(wrapperNode).select('.hist-tooltip')
        tip.classed('show', false)
        setTimeout(() => tip.style('display', 'none'), 140)
      })

  bars.transition()
      .duration(600)
      .attr('y', d => y(d.value))
      .attr('height', d => Math.max(0, height - y(d.value)))

  // Legend
  const legend = svg.append('g')
    .attr('class', 'legend')
    .attr('transform', `translate(${margin.left}, ${height + margin.top + 40})`)

  const itemSpacing = 110
  const legendItems = legend.selectAll('.legend-item')
    .data(rawTypes)
    .join('g')
      .attr('class', 'legend-item')
      .attr('transform', (d, i) => `translate(${(i % 5) * itemSpacing}, ${Math.floor(i / 5) * 22})`)

  legendItems.append('rect')
    .attr('width', 14)
    .attr('height', 14)
    .attr('rx', 3)
    .attr('fill', d => colorMap.get(d))

  legendItems.append('text')
    .attr('x', 20)
    .attr('y', 12)
    .text(d => d)
    .attr('fill', (cssVars && cssVars.getPropertyValue('--text-primary')) ? cssVars.getPropertyValue('--text-primary').trim() : '#eceffd')
    .attr('font-size', 13)
}
